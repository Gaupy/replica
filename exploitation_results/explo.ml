open Const
open Scanf
open Printf

let parse_config file =
  let chan = open_in file in
  let rmax = int_of_string (input_line chan) in
  let tree_type = int_of_string (input_line chan) in 
  let size_of_tree = int_of_string (input_line chan) in
  let number_of_speeds = int_of_string (input_line chan) in
  let static = float_of_string (input_line chan) in
  let max_speed = int_of_string (input_line chan) in
  let regularity_speed = int_of_string (input_line chan) in
  let number_of_tests = int_of_string (input_line chan) in
  let expe_number = int_of_string (input_line chan) in
  let () = close_in chan in
  {
  rmax = rmax;
  tree_type = tree_type;
  size_of_tree = size_of_tree;
  number_of_speeds = number_of_speeds;
  static = static;
  max_speed = max_speed;
  regularity_speed = regularity_speed;
  number_of_tests = number_of_tests;
  expe_number = expe_number
  }


let script config_file =
  let param = parse_config config_file in
(*  let nheur = param.size_of_tree in*)
(*  let tab = Array.make_matrix nheur 6 (0.,0.) in*)
  let break = ref true in
  let workon = ref 0 in
  let size_of_tree = param.size_of_tree in
  let number_of_speeds = param.number_of_speeds in
  let rmax = param.rmax in
  let tree_type = param.tree_type in
  let max_static= param.static in
  let max_speed = param.max_speed in
  let regularity_speed = param.regularity_speed in
  let number_of_tests = param.number_of_tests in
  let expe_number = param.expe_number in
  let number_heur = ref 10 in (*10 is an upper bound on the number of heuristics.*)

  let limit_lp = 
    match expe_number with
    | 0 | 4 -> 30
    | _ -> 25
  in
  
  (*Below are the array where we store the solutions to draw some nice plot with gnuplot.*)
  let tab_maxnodes = 
    match expe_number with 
      | _-> Array.make_matrix size_of_tree !number_heur (0.,0.)
  in
  let min_static = 0. in
  let static_increment = (max_static /. 20.) in
  let number_of_static = 1+ int_of_float ((max_static -. min_static)/. static_increment) in (*10 is the number of static energy tried, from for static, with an increment of 1000*)
  let tab_static_energy = 
    match expe_number with 
      | _-> Array.make_matrix number_of_static  !number_heur (0.,0.)
  in
  let load_increment = rmax/10 in (*we divise the possible loads in intervals of rmax.*)
  let max_load = size_of_tree * rmax in
  let number_of_load = max_load / load_increment in
  let tab_load = 
    match expe_number with 
      | _-> Array.make_matrix number_of_load  !number_heur (0.,0.)
  in
  
(*  let res_string = (sprintf "result_%d_%d_%d_%d.avg" size_of_tree number_of_speeds (string_of_int (int_of_float param.static)) expe_number) in *)
  let name_result = 
    match expe_number with 
      | 0 | 1 | 4 | 5 -> ("maxnodes_"^(string_of_int size_of_tree)^"_rmax="^(string_of_int (rmax))^"_treetype="^(string_of_int tree_type)^"_nspeed="^(string_of_int number_of_speeds)^"_maxspeed="^(string_of_int (max_speed))^"_typespeed="^(string_of_int regularity_speed)^"_static="^(string_of_int (int_of_float param.static))) 
      | 2 | 6 -> ("static_energy_"^(string_of_int (int_of_float param.static))^"_nodes="^(string_of_int size_of_tree)^"_rmax="^(string_of_int (rmax))^"_treetype="^(string_of_int tree_type)^"_nspeed="^(string_of_int number_of_speeds)^"_maxspeed="^(string_of_int (max_speed))^"_typespeed="^(string_of_int regularity_speed)) 
      | 3 | 7 -> ("load_nodes="^(string_of_int size_of_tree)^"_rmax="^(string_of_int (rmax))^"_treetype="^(string_of_int tree_type)^"_nspeed="^(string_of_int number_of_speeds)^"_maxspeed="^(string_of_int (max_speed))^"_typespeed="^(string_of_int regularity_speed)^"_static="^(string_of_int (int_of_float param.static))) 
   in
  let eps_file = (name_result^".eps") in 
  let res_string = (name_result^".avg") in
  let buff = ref (open_out res_string) in 
  let script_gnuplot = ref (open_out (name_result^".p")) in 
  while !break do
  try
    while true do
     printf "%d\t" !workon;
    (*First we get all the data from the file, step by step.*)
      let vertex_number = (scanf " %d " (fun d -> d)) in
      let static = float_of_int (scanf " %d " (fun f -> f)) in
      let expe = float_of_int (scanf " %d " (fun f -> f)) in
      let iter = float_of_int (scanf " %d " (fun f -> f)) in
      number_heur := (scanf " %d " (fun d -> d));
      let energy_min = Array.make !number_heur (max_float) in
      let server_min = Array.make !number_heur (-1) in
      let prec_max = Array.make !number_heur 0. in
      for i = 0 to !number_heur -1 do
        server_min.(i) <- (scanf " %d " (fun d -> d));
        energy_min.(i) <- (scanf " %f " (fun f -> f));
        prec_max.(i) <- (scanf " %f " (fun f -> f));
      done;
      let load = (scanf " %f " (fun f -> f)) in
      let res_opt = 
          if (vertex_number <= limit_lp) then (*when there are more than limit_lp servers we do not compute the optimal solution given by*)
            match expe_number with 
              | _ -> (scanf " %f " (fun f-> f)) 
          else 
            (energy_min.(0))
          in 
      incr workon;
      (*We now verify whether the data is valid or not (in case the roundups errors cannot be neglected)*)
      let precision = 0.0001 in
      let max_precision = ref 0. in 
        (for i=0 to !number_heur -1 do max_precision := max (!max_precision) prec_max.(i) done);
      let max_diff = ref 0. in
        (for i=0 to !number_heur -1 do max_diff := max (max (!max_diff) (prec_max.(0) -.prec_max.(i))) (prec_max.(i) -.prec_max.(0)) done);
      let incorrect_caml = ref false in
        (for i=1 to !number_heur -1 do incorrect_caml :=(!incorrect_caml || energy_min.(i) > energy_min.(0) +. 0.5 ) done);
      if (!incorrect_caml && (4 <= expe_number) && (expe_number <= 7)) then (printf "top") else
      if (!max_precision > precision ) && vertex_number <= limit_lp then () else
      if (!max_diff > precision ) && vertex_number > limit_lp then () else
      (let i = ref 0 in
        while !i < !number_heur && energy_min.(!i) >= 0.  do incr i done;
      if !i < !number_heur then printf "Erreur dans calcul Caml (heur %d)\n" !i else
      ( i:=0; while !i < !number_heur && energy_min.(!i) >= res_opt  do incr i done;
      if vertex_number <= limit_lp  && !i < !number_heur then printf "Erreur dans une solution du LP (heur %d)\n" !i else
      if res_opt < 0. then printf "Erreur dans calcul du LP\n" else


     (*Finally we treat the data.*)
     for i= 0 to !number_heur - 1 do
       let ratio = energy_min.(i) /. res_opt in
       match expe_number with
         | 0 | 1 | 4 | 5 -> let (j,r) = tab_maxnodes.(vertex_number).(i) in
           tab_maxnodes.(vertex_number).(i) <- (j+.1., r+. ratio)
         | 2 | 6 -> let ind_static = int_of_float ((static -. min_static)/. static_increment) in
           (let (j,r) = tab_static_energy.(ind_static).(i) in
           tab_static_energy.(ind_static).(i) <- (j+.1., r+. ratio))
         | 3 | 7 -> let ind_load = int_of_float (load /. (float_of_int load_increment)) in
           let (j,r) = tab_load.(ind_load).(i) in
           tab_load.(ind_load).(i) <- (j+.1., r+. ratio)
     done;
      ))
    done
  with
    |Scan_failure _ -> ()
    |End_of_file -> 
      begin
(*       printf "ici\n";*)
(*       flush stdout;*)
        break := false ;
        let low_bound_gnuplot = ref 0 in (*x-axis*)
        let low_bound = !low_bound_gnuplot in
        let upper_bound_gnuplot =
          match expe_number with
            | 0 | 1 | 4 | 5 -> ref (size_of_tree -1)
            | 2 | 6 -> ref (number_of_static -1)
            | 3 | 7 -> ref (number_of_load -1)
        in (*x-axis*)
        let upper_bound = !upper_bound_gnuplot in
        let worse_case = ref 1. in (*y-axis*)
        let best_case = ref 1. in (*y-axis*)
        let x_label = 
          match expe_number with 
            | 0 | 1 | 4 | 5 -> "Number of nodes"
            | 2 | 6 -> "Static power"
            | 3 | 7 -> "# requests"
        in
        let y_label = if (size_of_tree <= limit_lp) then "Eg / Eg_opt" else "Eg / Eg_greedy" in
        let tab = 
          match expe_number with 
            | 0 | 1 | 4 | 5 -> tab_maxnodes
            | 2 | 6 -> tab_static_energy
            | 3 | 7 -> tab_load
        in
        let min_representative = 50. in (*If a value has less than min_reprentative points, then it is not representative.*)
        for i = 0 to !number_heur -1 do (*we consider the lower bound on the x-axis*)
          let j = ref (fst  tab.(!low_bound_gnuplot).(i)) in
          while !low_bound_gnuplot < !upper_bound_gnuplot && !j < min_representative do
            j:= fst tab.(!low_bound_gnuplot).(i);
            incr low_bound_gnuplot
          done
        done;
        for i = 0 to !number_heur -1 do(*we consider the upper bound on the x-axis*)
          let j = ref (fst  tab.(!upper_bound_gnuplot).(i)) in
          while !low_bound_gnuplot < !upper_bound_gnuplot && !j < min_representative do
            j:= fst tab.(!upper_bound_gnuplot).(i);
            decr upper_bound_gnuplot
          done
        done;
        for i = low_bound to upper_bound do
          let index = 
            match expe_number with
              | 0 | 1 | 4 | 5 -> i
              | 2 | 6 -> int_of_float (min_static +. (float_of_int i)*. static_increment)
              | 3 | 7 -> i * load_increment
          in
          fprintf !buff "%d\t" index ;
          for k = 0 to !number_heur -1 do
            let j,r = tab.(i).(k) in
            if j=0. then (fprintf !buff "-\t")
            else (fprintf !buff "%f\t" (r/.j) ; worse_case := max !worse_case (r/.j +. 0.2); if r/.j > 0.5 then best_case := min !best_case (r/.j -. 0.005));
                  fprintf !buff "%d \t" (int_of_float j)
          done;
          fprintf !buff "\n";
        done;
        let () = low_bound_gnuplot := 
          match expe_number with
            | 0 | 1 | 4 | 5 -> !low_bound_gnuplot-1
            | 2 | 6 -> int_of_float (min_static +. (float_of_int !low_bound_gnuplot)*. static_increment)
            | 3 | 7 -> (!low_bound_gnuplot -1) * load_increment in
        let () = upper_bound_gnuplot := 
          match expe_number with
            | 0 | 1 | 4 | 5 -> !upper_bound_gnuplot
            | 2 | 6 -> int_of_float (min_static +. (float_of_int !upper_bound_gnuplot)*. static_increment)
            | 3 | 7 -> (!upper_bound_gnuplot+1) * load_increment in
        fprintf !script_gnuplot "%s"
          ("set terminal postscript eps color\nset output \""^
          eps_file^
          "\"\nset boxwidth 0.1\nset key right top\nset xlabel \""^x_label^"\"\nset ylabel \""^y_label^"\"\n"^
          (sprintf "set xrange [%d:%d]\nset yrange [%f:%f]\n" (!low_bound_gnuplot) (!upper_bound_gnuplot) !best_case !worse_case )^
          "set border 3\nset xtics nomirror\nset ytics nomirror\nplot \"");
        let tab_name = Array.make !number_heur "" in
        let () =
          match expe_number with
            | 4 | 5 | 6 | 7 -> if !number_heur = 3 then (tab_name.(0) <- "Greedy"; tab_name.(1) <- "Speed"; tab_name.(2) <- "Excess") else (for k = 0 to !number_heur -1 do tab_name.(k) <- sprintf "Heur%d" k done)
            | 0 | 2 | 3 | _ -> (for k = 0 to !number_heur -1 do tab_name.(k) <- sprintf "Heur%d" k done) 
          in
        for k=0 to !number_heur -2 do
          fprintf !script_gnuplot "%s"
                    (res_string^(sprintf "\" using 1:%d with lines lt %d title \"" (2*(k+1)) k)^tab_name.(k)^"\",\\\n\"")
        done;
        let k = !number_heur -1 in
        fprintf !script_gnuplot "%s" (res_string^(sprintf "\" using 1:%d with lines lt %d title \"" (2*(k+1)) k)^tab_name.(k)^"\"\n");
        fprintf !script_gnuplot "%s"
          ("!epstopdf \""^eps_file^"\""^
          "\n!rm \""^eps_file^"\""^
          "\nunset output")
      end
     | _ -> ()
done


let () = script Sys.argv.(1)





(*let script config_file =*)
(*  let limit_lp = 25 in*)
(*  let param = parse_config config_file in*)
(*  let nheur = param.size_of_tree in*)
(*  let tab = Array.make_matrix nheur 6 (0.,0.) in*)
(*  let break = ref true in*)
(*  let workon = ref 0 in*)
(*  let size_of_tree = param.size_of_tree in*)
(*  let number_of_speeds = param.number_of_speeds in*)
(*  let rmax = param.rmax in*)
(*  let tree_type = param.tree_type in*)
(*  let static= 0 in*)
(*  let max_speed = param.max_speed in*)
(*  let regularity_speed = param.regularity_speed in*)
(*  let number_of_tests = param.number_of_tests in*)
(*  let expe_number = param.expe_number in*)
(*  let buff = ref (open_out ("result_"^(string_of_int size_of_tree)^"_"^(string_of_int number_of_speeds)^"_"^(string_of_int expe_number)^".avg")) in *)
(*  let script_gnuplot = ref (open_out ((string_of_int (rmax))^"_"^(string_of_int tree_type)^"_"^(string_of_int size_of_tree)^"_"^(string_of_int number_of_speeds)^"_"^(string_of_int static)^"_"^(string_of_int (max_speed))^"_"^(string_of_int regularity_speed)^"_"^(string_of_int expe_number)^".p")) in *)
(*  while !break do*)
(*  try*)
(*    while true do*)
(*      let vertex = (scanf " %f " (fun f -> f)) in*)
(*      let servers = (scanf " %f " (fun f -> f)) in*)
(*      let iteration = (scanf " %f " (fun f -> f)) in*)
(*      let precision_greedy = (scanf " %f " (fun f -> f)) in*)
(*      let precision_move1 = (scanf " %f " (fun f -> f)) in*)
(*      let precision_move2 = if expe_number =1 then (scanf " %f " (fun f -> f)) else 0. in*)
(*      let res_greedy = (scanf " %f " (fun f -> f)) in*)
(*      let res_move1 = (scanf " %f " (fun f -> f)) in 												(*res_move1 is res_greedy_bis in the case of expe 2 *)*)
(*      let res_move2 = if (expe_number =1) || (expe_number = 2)|| (expe_number = 3) then (scanf " %f " (fun f -> f)) else 0. in	(*res_move2 is res_worse in the case of expe 2 *)*)
(*      let res_opt, res_greedy_opt, res_move1_opt, res_move2_opt = *)
(*          if (size_of_tree <= limit_lp) then (*when there are more than limit_lp servers we do not compute the optimal solution given by*)*)
(*            (match expe_number with *)
(*              | 1 -> (scanf " %f %f %f %f " (fun a b c d -> (a, b, c, d))) *)
(*              |_ ->  scanf " %f %f  " (fun a b -> (a, b, 1., 1.))*)
(*            )*)
(*          else *)
(*            (res_greedy,1.,1.,1.)*)
(*          in *)
(*      incr workon;*)
(*        let precision = 0.0001 in*)
(*        if (precision_greedy > precision || precision_greedy < -. precision ) && size_of_tree <= limit_lp then () else*)
(*        if (precision_move1 > precision || precision_move1 < -. precision ) && size_of_tree <= limit_lp then () else*)
(*        if (precision_move2 > precision || precision_move2 < -. precision ) && size_of_tree <= limit_lp && expe_number =1  then () else*)
(*        if (precision_greedy -. precision_move1 > precision || precision_greedy -. precision_move1 < -. precision ) && size_of_tree > limit_lp then () else*)
(*        if (precision_greedy -. precision_move2 > precision || precision_greedy -. precision_move2 < -. precision ) && size_of_tree > limit_lp  && expe_number =1 then () else*)
(*        if expe_number =2 && (res_move2 < res_greedy ) then printf "Erreur dans code Caml greedy %f %f\n" res_greedy res_move2 else*)
(*        if expe_number =2 && (res_move2 < res_move1) then printf "Erreur dans code Caml move 1 %f %f \n" res_move1 res_move2 else*)
(*        if res_opt < 0. || res_greedy_opt <0. then printf "Erreur dans une solution du LP\n" else*)
(*        if expe_number =1 && (res_move1_opt < 0. || res_move2_opt < 0.) then printf "Erreur dans une solution du LP\n" else*)
(*	if res_greedy < res_opt && size_of_tree <= limit_lp then printf "Erreur dans l'energie de l'heuristique greedy %f %d\n" (res_greedy/.res_opt) !workon else*)
(*	if res_move1 < res_opt && size_of_tree <= limit_lp then printf "Erreur dans l'energie de l'heuristique move1 %f %d\n" (res_move1/.res_opt) !workon else*)
(*	if res_move2 < res_opt && size_of_tree <= limit_lp  && expe_number =1 then printf "Erreur dans l'energie de l'heuristique move2 %f %d\n" (res_move2/.res_opt) !workon else*)
(*	if res_greedy_opt < res_opt && size_of_tree <= limit_lp then printf "Erreur dans l'energie du LP greedy %f %d\n" (res_greedy_opt/.res_opt) !workon else *)
(*	if res_move1_opt < res_opt && size_of_tree <= limit_lp  && expe_number =1 then printf "Erreur dans l'energie du LP move1 %f %d\n" (res_move1_opt/.res_opt) !workon else *)
(*	if res_move2_opt < res_opt && size_of_tree <= limit_lp  && expe_number =1  then printf "Erreur dans l'energie du LP move2 %f %d\n" (res_move2_opt/.res_opt) !workon else *)
(*	let temp = (int_of_float servers) -1  in*)
(*        ( *)
(*        let r2 = res_greedy/.res_opt in*)
(*           let (j,r) = tab.(temp).(0) in *)
(*             tab.(temp).(0)<-(j+.1.,r+.r2);*)
(*         let r3 = res_greedy_opt/.res_opt in *)
(*           let (j,r) = tab.(temp).(1) in *)
(*             tab.(temp).(1)<-(j+.1.,r+.r3); *)
(*        let r4 = res_move1/.res_opt in*)
(*           let (j,r) = tab.(temp).(2) in *)
(*             tab.(temp).(2)<-(j+.1.,r+.r4);*)
(*         let r5 = res_move1_opt/.res_opt in *)
(*           let (j,r) = tab.(temp).(3) in *)
(*             tab.(temp).(3)<-(j+.1.,r+.r5); *)
(*        let r6 = res_move2/.res_opt in*)
(*           let (j,r) = tab.(temp).(4) in *)
(*             tab.(temp).(4)<-(j+.1.,r+.r6);*)
(*         let r7 = res_move2_opt/.res_opt in *)
(*           let (j,r) = tab.(temp).(5) in *)
(*             tab.(temp).(5)<-(j+.1.,r+.r7); *)
(*        )*)
(*    done*)
(*  with*)
(*    |Scan_failure _ -> ()*)
(*    |End_of_file -> *)
(*      begin*)
(*        break := false ;*)
(*        let low_bound_gnuplot = ref 1 in*)
(*        let worse_case = ref 1. in*)
(*        let best_case = ref 1. in*)
(*          if (size_of_tree <= limit_lp) then (*Case where we compare with linear programming *)*)
(*            begin*)
(*            for i = 0 to nheur-1 do*)
(*              fprintf !buff "%d\t" (i+1) ;*)
(*              for k=0 to 5 do*)
(*                let j,r = tab.(i).(k) in*)
(*                  if j=0. then (fprintf !buff "-1.\t")*)
(*                  else (fprintf !buff "%f\t" (r/.j) ; worse_case := max !worse_case (r/.j +. 0.2));*)
(*                  fprintf !buff "%d \t" (int_of_float j)*)
(*              done;*)
(*            fprintf !buff "\n"*)
(*            done;*)
(*            for i=0 to nheur-1 do*)
(*              let j,r = tab.(i).(0) in *)
(*              if j < 10. then  incr low_bound_gnuplot*)
(*            done;*)
(*            end*)
(*          else (*When we do not compare to linear programming*)*)
(*            begin*)
(*            for i = 0 to nheur-1 do*)
(*              fprintf !buff "%d\t" (i+1) ;*)
(*              for k=0 to 5 do*)
(*                let j,r = tab.(i).(k) in*)
(*                  if j=0. then (fprintf !buff "-1.\t")*)
(*                  else (fprintf !buff "%f\t" (r/.j) ; worse_case := max !worse_case (r/.j +. 0.005); if r/.j > 0.5 then best_case := min !best_case (r/.j -. 0.005));*)
(*                  fprintf !buff "%d \t" (int_of_float j)*)
(*              done;*)
(*            fprintf !buff "\n"*)
(*            done;*)
(*            for i=0 to nheur-1 do*)
(*              let j,r = tab.(i).(0) in *)
(*              if j < 10. then  incr low_bound_gnuplot*)
(*            done;*)
(*            end;*)
(*        let res_string = (sprintf "result_%d_%d_%d.avg" size_of_tree number_of_speeds expe_number) in *)
(*        let eps_file = ((string_of_int (rmax))^"_"^(string_of_int tree_type)^"_"^(string_of_int size_of_tree)^"_"^(string_of_int number_of_speeds)^"_"^(string_of_int (max_speed))^"_"^(string_of_int regularity_speed)^"_"^(string_of_int number_of_tests)^"_"^(string_of_int expe_number)^".eps") in *)
(*	if expe_number = 1 then (*First experiment*)*)
(*          begin*)
(*            if (size_of_tree <= limit_lp) then *)
(*             (fprintf !script_gnuplot "%s"*)
(*             ("set terminal postscript eps color\nset output \""^*)
(*             eps_file^*)
(*             "\"\nset boxwidth 0.1\nset key right top\nset xlabel \"Number of servers\"\nset ylabel \"Eg / Eg_opt\"\n"^*)
(*             (sprintf "set xrange [%d:%d]\nset yrange [1:%f]\n" (!low_bound_gnuplot) size_of_tree !worse_case )^*)
(*             "set border 3\nset xtics nomirror\nset ytics nomirror\nplot \""^*)
(*             res_string^"\" using 1:2 with lines lt 7 title \"Greedy\",\\\n\""^*)
(*             res_string^"\" using 1:4 with lines lt 3 title \"Same Location Greedy\",\\\n\""^*)
(*             res_string^"\" using 1:6 with lines lt 5 title \"Move 1\",\\\n\""^*)
(*             res_string^"\" using 1:8 with lines lt 4 title \"Same Location Move 1\",\\\n\""^*)
(*             res_string^"\" using 1:10 with lines lt 9 title \"Move 2\",\\\n\""^*)
(*             res_string^"\" using 1:12 with lines lt 8 title \"Same Location Move 2\"\n"^*)
(*             "!epstopdf "^eps_file^*)
(*             "\n!rm "^eps_file^*)
(*             "\nunset output" ))*)
(*              else *)
(*             (fprintf !script_gnuplot "%s"*)
(*             ("set terminal postscript eps color\nset output \""^*)
(*             eps_file^*)
(*             "\"\nset boxwidth 0.1\nset key right top\nset xlabel \"Number of servers\"\nset ylabel \"Eg / Eg_greedy\"\n"^*)
(*             (sprintf "set xrange [%d:%d]\nset yrange [%f:%f]\n" (!low_bound_gnuplot) size_of_tree !best_case !worse_case )^*)
(*             "set border 3\nset xtics nomirror\nset ytics nomirror\nplot \""^*)
(*             res_string^"\" using 1:2 with lines lt 7 title \"Greedy\",\\\n\""^*)
(*             res_string^"\" using 1:6 with lines lt 5 title \"Move 1\",\\\n\""^*)
(*             res_string^"\" using 1:10 with lines lt 9 title \"Move 2\"\n"^*)
(*             " !epstopdf "^eps_file^*)
(*             "\n!rm "^eps_file^*)
(*             "\nunset output" ))*)
(*          end*)
(*        else (*Second experiment.*)*)
(*          begin*)
(*            if (size_of_tree <= limit_lp) then *)
(*             (fprintf !script_gnuplot "%s"*)
(*             ("set terminal postscript eps color\nset output \""^*)
(*             eps_file^*)
(*             "\"\nset boxwidth 0.1\nset key right top\nset xlabel \"Number of servers\"\nset ylabel \"Eg / Eg_opt\"\n"^*)
(*             (sprintf "set xrange [%d:%d]\nset yrange [1:%f]\n" (!low_bound_gnuplot) size_of_tree !worse_case )^*)
(*             "set border 3\nset xtics nomirror\nset ytics nomirror\nplot \""^*)
(*             res_string^"\" using 1:2 with lines lt 7 title \"Greedy Alloc 1\",\\\n\""^*)
(*             res_string^"\" using 1:6 with lines lt 5 title \"Greedy Alloc 2\",\\\n\""^*)
(*             res_string^"\" using 1:10 with lines lt 9 title \"Greedy worse alloc\",\\\n\""^*)
(*             res_string^"\" using 1:4 with lines lt 3 title \"Same Location Greedy\"\n"^*)
(*             "!epstopdf "^eps_file^*)
(*             "\n!rm "^eps_file^*)
(*             "\nunset output" ))*)
(*              else *)
(*             (fprintf !script_gnuplot "%s"*)
(*             ("set terminal postscript eps color\nset output \""^*)
(*             eps_file^*)
(*             "\"\nset boxwidth 0.1\nset key right top\nset xlabel \"Number of servers\"\nset ylabel \"Eg / Eg_greedy\"\n"^*)
(*             (sprintf "set xrange [%d:%d]\nset yrange [%f:%f]\n" (!low_bound_gnuplot) size_of_tree !best_case !worse_case )^*)
(*             "set border 3\nset xtics nomirror\nset ytics nomirror\nplot \""^*)
(*             res_string^"\" using 1:2 with lines lt 7 title \"Greedy Alloc 1\",\\\n\""^*)
(*             res_string^"\" using 1:6 with lines lt 5 title \"Greedy Alloc 2\",\\\n\""^*)
(*             res_string^"\" using 1:10 with lines lt 9 title \"Greedy worse alloc\"\n"^*)
(*             " !epstopdf "^eps_file^*)
(*             "\n!rm "^eps_file^*)
(*             "\nunset output" ))*)
(*          end*)
(*      end*)
(*     | _ -> ()*)
(*done*)


(*let () = script Sys.argv.(1)*)
